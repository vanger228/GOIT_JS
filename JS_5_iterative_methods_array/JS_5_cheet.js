// Виділю важливу (на мою думку) інформацію:
// Щоразу, коли потрібно обробити масив, не обов‘язково використовувати цикли або винаходити велосипед. Найімовірніше, це вже зробили за вас.
// Пошукайте відповідний метод. У більшості випадків завдання можна буде вирішити за допомогою методів map(), filter(), reduce() або spread-оператора.
// Ніколи не завадить вміння застосовувати методи slice(), some(), flatMap() тощо. Використовуйте їх, коли це буде доцільно.
// Завжди пам‘ятайте, які методи створюють новий масив, а які модифікують (мутують) вже існуючий. Інакше можна наламати дров.
// Метод slice() та spread-оператор роблять поверхневу копію масиву. Тому масиви та підмасиви будуть посилатися на один і той самий об‘єкт у пам’яті.
// “Старі” методи, що змінюють масив, мають сучасні аналоги. Ретельно вибирайте використовувані методи.
// ----forEach
// arr.forEach(function (item, i) {});

// -----Псевдомасив arguments

// У стрілочних функцій немає локальної змінної arguments, що містить усі аргументи. Якщо необхідно зібрати всі аргументи в масив, використовується операція rest.

// const add = (...args) => {
//   console.log(args);
// };

// add(1, 2, 3); // [1, 2, 3]

//  ----Метод map(callback)
//  використовується для трансформації масиву.Він викликає колбек - функцію для кожного елемента вихідного масиву, а результат її роботи записує в новий масив, який і буде результатом виконання методу.

// array.map((element, index, array) => {
//   // Тіло колбек-функції
// });

// ----Метод filter()

// array.filter((element, index, array) => {
//   // Тіло колбек-функції
// });

// Не змінює оригінальний масив.
// Поелементно перебирає оригінальний масив.
// Повертає новий масив.
// Додає в масив, що повертається, елементи, які задовольняють умову колбек-функції.
// Якщо колбек повернув true, елемент додається в масив, що повертається.
// Якщо колбек повернув false, елемент не додається в масив, що повертається.
// Якщо жоден елемент не задовольнив умову, повертає порожній масив.

// ----Метод find()
// шукає і повертає перший елемент що задовільняє перевірку перебору
// Не змінює оригінальний масив
// Поелементно перебирає оригінальний масив
// Повертає перший елемент, що задовольняє умову, тобто коли колбек повертає true
// Якщо жоден елемент не задовольнив умову, тобто для всіх елементів колбек повернув false, метод повертає undefined

// ----Метод every()

// Метод every(callback) перевіряє, чи задовольняють усі елементи умову колбек-функції.
// Не змінює оригінальний масив
// Поелементно перебирає оригінальний масив
// Повертає true, якщо всі елементи масиву задовольняють умову
// Повертає false, якщо хоча б один елемент масиву не задовольняє умову
// Перебирання масиву припиняється, якщо колбек повертає false

// const result = [1, 2, 3, 4, 5].every(value => value > 0);
// console.log(result); //true
// const result1 = [1, -2, 3, 4, 5].every(value => value > 0);
// console.log(result1); //false

// ----Метод some()

// Метод some(callback) перевіряє, чи задовольняє хоча б один елемент умову колбек-функції.

// Доповни функцію isAnyUserActive(users) таким чином, щоб вона перевіряла наявність хоча б одного активного користувача (властивість isActive) і повертала true або false.

// const isAnyUserActive = users => {
//   return users.some(user => user.isActive === true);
// };

// ----Метод reduce()

// Метод reduce(callback, initialValue) використовується для послідовної обробки кожного елемента масиву із збереженням проміжного результату. Трохи складніший за інші методи для засвоєння, але результат вартий того.

// array.reduce((acc, element, index, array) => {
//   // Тіло колбек-функції
// }, initialValue);

// Не змінює оригінальний масив
// Поелементно перебирає оригінальний масив
// Повертає все, що завгодно (об’єкт, масив, рядок, число тощо)
// Може замінити функціонал будь-якого іншого перебираючого методу масиву та навіть їх комбінацію

// Колбек-функція з параметра редьюса очікує в свою чергу чотири параметри. Ці параметри, так само як і в колбеках інших перебираючих методів масиву, можна не оголошувати, якщо вони вам не потрібні, але не можна порушувати їх послідовність:

// 1-й параметр (acc) — це акумулятор, тобто проміжний результат. Значення, яке поверне колбек-функція на поточній ітерації, буде значенням цього параметра на наступній ітерації;

// !! Обов'язково задаємо початковий аккум після колбека

// 2-й параметр — поточний елемент масиву;

// 3-й параметр — індекс поточної ітерації;

// 4-й параметр — посилання на вихідний масив.

// Найлегше уявити його роботу на прикладі підрахунку суми елементів масиву.

// const total = [2, 7, 3].reduce((acc, number) => {
//   return acc + number;
// }, 0);

// console.log(total); // 12

// Розгляньмо детальніше роботу редьюса у прикладі вище:

// Початкове значення акумулятора 0
// перша ітерація колбек-функції 0 + 2 поверне 2
// друга ітерація колбек-функції 2 + 7 поверне 9
// третя ітерація колбек-функції 9 + 3 поверне 12

// Результатом коду вище буде 12.

//----Метод toSorted

// Масив чисел

// Розгляньмо приклад, де потрібно відсортувати масив scores.

// Вихідний масив scores залишається незмінним. Новий масив ascendingScores містить масив чисел, що відсортований за зростанням.

// const scores = [61, 19, 74, 35, 92, 56];
// const ascendingScores = scores.toSorted();
